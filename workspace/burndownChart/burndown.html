<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Burndown Chart</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
	<style>
		html, body {
			margin: 0;
			padding: 0
		}

		body {
			background-color: #ebebeb;
		}

	</style>
</head>
<body>
	<script type="module">

	const height = 500
	const width = 1000
	const svg = d3.select("body")
		.append("svg")
		.attr("width", "100%")
		.attr("height", "100%")
		.attr("viewBox", `0, 0, ${width}, ${height}`)
		.attr("preserveAspectRatio", "none")

	const statusMap = await d3.tsv("./steps.tsv")
	const statusLookup = d3.index(statusMap, d => d.stepName)
	const rawData = await d3.tsv("./burndownData.csv")

	const refYear = d3.mode(rawData, d => d.referenceYear)

	const dimTable = d3.group(rawData.map(audit => {
		const facts = { ... audit }
		delete facts.workstep
		delete facts.doneAt
		delete facts.doneBy
		delete facts.furtherSpecification
		delete facts.duration
		return facts
	}), d => d.auditId)

	const minDate = d3.min(rawData, d => new Date(d.doneAt))

	const worklog = d3.groups(rawData.filter(audit => audit.doneAt).map(audit => {
		const [day, month, year] = audit.doneAt.split(".")
		const workstep = statusLookup.get(audit.workstep)
		if (workstep === undefined) throw Error("undefined workstep " + audit.workstep)
		return {
			id: audit.auditId,
			workstep,
			doneAt: new Date(Number(year), Number(month) - 1, Number(day)),
			doneBy: audit.doneBy,
			furtherSpecification: audit.furtherSpecification,
			duration: audit.duration
		}
	}), d => d.id)

	const progressionData = worklog.map(logPerID => {
		const [id, logs] = logPerID
		// if it's only Beginn return blank array, we'll add the +1 Beginn status later

		const processLogs = (logs) => {
			if (logs.length === 1) return []
			let currentStatus = statusLookup.get("Beginn")
			const returnArray = logs.map(log => {
				// const isNewStatusHigher = log.workstep.stageId >= currentStatus.stageId
				const returnObj = [
					{ id, date: log.doneAt, status: currentStatus, value: -1 },
					{ id, date: log.doneAt, status: log.workstep, value: 1 }
				 ]
				 currentStatus = log.workstep
				return returnObj
			})

			const flattened = returnArray.flat()
			return flattened
		}

		const processedLogs = processLogs(logs)
		return [...processedLogs, { id, date: minDate, status: statusLookup.get("Beginn"), value: 1 }]
	})

	const groupedByStatusId = d3.groups(progressionData.flat(), d => Number(d.status.id), d => d.date)
			.toSorted((a, b) => a[0] - b[0])
			.map(d => {
				d[1].map(d => {
					d[1] = d3.sum(d[1].map(d => d.value))
					return d
				})
				d[1].sort((a, b) => a[0] - b[0])
			return d
			})

	const orderedGroups = groupedByStatusId.map(pair => {
		const [statusId, valueProgression] = pair
		valueProgression.toSorted((a, b) => a.date - b.date)
		let cumsum = 0
		const accumulated = valueProgression.map(d => {
			const [date, value] = d
			const returnObj = { date, value, statusId, cumsum}
			cumsum += value
			return returnObj
		})
		return accumulated
	})

	const flatten = orderedGroups.flat()
	console.log(flatten)
	const stackFunction = d3.stack()
		.keys(flatten, d => d.statusId)
		.value(([, group], key) => group.get(key).cumsum)

	stackFunction(flatten)

	const margin = { left: 50, top: 10, bottom: 50, right: 10 }
	const canvas = svg
		.append("g")
		.attr("class", "canvas")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)

	const axes = svg.append("g").attr("class", "axes")

	const xScale = d3.scaleTime()
		.domain(d3.extent(rawData, d => new Date(d.doneAt)))
		.range([0, width - margin.left - margin.right])

	const yScale = d3.scaleLinear()
		.domain([0, groupByAuditId.length])
		.range([height - margin.bottom, 0])


	axes
		.append("g")
		.attr("class", "x axis")
		.attr("transform", `translate(${margin.left}, ${height - margin.bottom})`)
		.call(d3.axisBottom(xScale))

	axes
		.append("g")
		.attr("class", "y axis")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)
		.call(d3.axisLeft(yScale))

	const colorScale = d3.scaleSequential(d3.interpolateCool).domain([0,14])
	const areaGenerator = d3.area(d => xScale(d[0]), yScale(0), d => yScale(d[1]))

	const plots = canvas.selectAll("path").data(orderedGroups)
			.enter()
			.append("path")
			.attr("class", "plot")
			.attr("id", (d) => d[0])
			.attr("fill", (d, i) => colorScale(i))
			.attr("opacity", 0.2)
			.attr("stroke", (d, i) => colorScale(i))
			.attr("d", d => areaGenerator(d[1]))
	</script>
</body>
</html>
