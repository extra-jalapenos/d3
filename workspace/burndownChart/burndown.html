<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Burndown Chart</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
	<style>
		html, body {
			margin: 0;
			padding: 0
		}

		body {
			background-color: #ebebeb;
		}

	</style>
</head>
<body>
	<script type="module">

	const height = 500
	const width = 1000
	const svg = d3.select("body")
		.append("svg")
		.attr("width", "100%")
		.attr("height", "100%")
		.attr("viewBox", `0, 0, ${width}, ${height}`)
		.attr("preserveAspectRatio", "none")

	const statusMap = await d3.tsv("./steps.tsv")
	const statusLookup = d3.index(statusMap, d => d.stepName)
	const rawData = await d3.tsv("./burndownData.csv")
	const worklogsByDateAsc = rawData.map(d => {
		const [day, month, year] = d.doneAt.split(".").map(digit => Number(digit))
		return { auditId: d.auditId, workstep: statusLookup.get(d.workstep), date: new Date(year, month-1, day), dateStr: String(new Date(year, month-1, day))}
	}).filter(d => String(new Date(d.dateStr)) !== "Invalid Date")
	.sort((a, b) => a.date < b.date)


	const refYear = Number(d3.mode(rawData, d => d.referenceYear))
	const minDate = d3.min(rawData, d => new Date(d.doneAt))

	// to calculate the progression, we'll need to group by audit
	const sortedWorklogsByAuditId = d3.groups(worklogsByDateAsc, d => d.auditId)

	const progressionData = sortedWorklogsByAuditId.map(auditIdGroup => {
		const [auditId, auditWorklogs] = auditIdGroup

		const processLogs = () => {
			// if it's only Beginn return blank array, we'll add the +1 Beginn status later
			if (auditWorklogs.length <= 1) return []
			let currentStatus = statusLookup.get("Beginn")
			const statusProgressionLog = auditWorklogs.map(auditWorklog => {
				const returnTuple = [
					{ auditId, date: auditWorklog.date, status: currentStatus, value: -1 },
					{ auditId, date: auditWorklog.date, status: auditWorklog.workstep, value: 1 }
				 ]
				 currentStatus = auditWorklog.workstep
				return returnTuple
			})

			return statusProgressionLog.flat()
		}

		const processedLogs = processLogs()
		return [{ auditId: auditId, date: minDate, status: statusLookup.get("Beginn"), value: 1 }, ...processedLogs]
	}).flat()

	// add a running value to each statusId

	// first, sum per statusID
	const valueChangePerStatusId = d3.group(progressionData, d => Number(d.status.id))

	// now we make a fucking map over the time range
	const flatProgressionArray = []

	for (const statusId of valueChangePerStatusId.keys()) {
		const entriesInStatus = valueChangePerStatusId.get(statusId)

		let valueProgression = 0
		const valueChangePerDay = d3.groups(entriesInStatus, d => d.date)
			.sort((D1, D2) => D1[0] - D2[0])
			.map(D => {
				const change = d3.sum(D[1].map(d => d.value))
				valueProgression += change
				flatProgressionArray.push({ date: D[0], statusId, value: change, valueProgression })
				return { date: D[0], value: change, valueProgression }
			})

		valueChangePerStatusId.set(statusId, valueChangePerDay)
	}

	const distinctDates = d3.union(flatProgressionArray.map(d => [d.date, { value: d.value }]).sort((a, b) => a[0] - b[0]))
	// go through all dates and if there's no value for an ID set its value to 0
	const distinctDatesInternMap = new d3.InternMap(distinctDates)


	const referenceMap = new d3.InternMap(statusMap.map(status => [String(status.id), distinctDatesInternMap]))
	// first, fill fact dates
	for (const entriesForStatus of referenceMap) {
		const [statusKeyString, dateMap] = entriesForStatus
		for (const dateKey of dateMap) {
			const [date, obj] = dateKey

		}
	}

	const margin = { left: 50, top: 10, bottom: 50, right: 10 }
	const canvas = svg
		.append("g")
		.attr("class", "canvas")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)

	const axes = svg.append("g").attr("class", "axes")

	const xScale = d3.scaleTime()
		.domain([new Date(refYear, 0, 1), new Date(refYear + 1, 5, 30)])
		.range([0, width - margin.left - margin.right])

	xScale.clamp(true)

	const yScale = d3.scaleLinear()
		.domain([0, sortedWorklogsByAuditId.length])
		.range([height - margin.bottom, 0])


	axes
		.append("g")
		.attr("class", "x axis")
		.attr("transform", `translate(${margin.left}, ${height + margin.top - margin.bottom})`)
		.call(d3.axisBottom(xScale))

	axes
		.append("g")
		.attr("class", "y axis")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)
		.call(d3.axisLeft(yScale))

	const colorScale = d3.scaleOrdinal([
		...d3.schemeGreys[4],
		"green",
		...d3.schemeBlues[4],
		"rebeccapurple",
		"black",
		...d3.schemeOranges[4]
	])

	const areaGenerator = d3.area(d => xScale(d.date),
		d => yScale(0),
		d => yScale(d.valueProgression)).curve(d3.curveStep)
		.defined(d => d.date)

	const plots = canvas.selectAll("path").data(Array.from(valueChangePerStatusId).sort((a, b) => a[0] - b[0]))
			.enter()
			.append("path")
			.attr("class", "plot")
			.attr("id", (d, i) => i)
			.attr("fill", (d, i) => colorScale(i))
			.attr("opacity", 0.5)
			.attr("stroke", (d, i) => colorScale(i))
			.attr("d", d => areaGenerator(d[1]))
	</script>
</body>
</html>
