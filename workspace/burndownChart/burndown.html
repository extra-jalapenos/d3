<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Burndown Chart</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
	<style>
		html, body {
			margin: 0;
			padding: 0
		}

		body {
			background-color: #ebebeb;
		}

	</style>
</head>
<body>
	<script type="module">

	const height = 500
	const width = 1000
	const svg = d3.select("body")
		.append("svg")
		.attr("width", "100%")
		.attr("height", "100%")
		.attr("viewBox", `0, 0, ${width}, ${height}`)
		.attr("preserveAspectRatio", "none")

	const statusMap = await d3.tsv("./steps.tsv")
	const statusLookup = d3.index(statusMap, d => d.stepName)
	const rawData = await d3.tsv("./burndownData.csv")
	const worklogsByDateAsc = rawData.map(d => {
		const [day, month, year] = d.doneAt.split(".").map(digit => Number(digit))
		return { auditId: d.auditId, workstep: statusLookup.get(d.workstep), date: new Date(year, month-1, day), dateStr: String(new Date(year, month-1, day))}
	}).filter(d => String(new Date(d.dateStr)) !== "Invalid Date")
	.sort((a, b) => a.date < b.date)


	const refYear = Number(d3.mode(rawData, d => d.referenceYear))
	const minDate = d3.min(rawData, d => new Date(d.doneAt))

	// to calculate the progression, we'll need to group by audit
	const sortedWorklogsByAuditId = d3.group(worklogsByDateAsc, d => d.auditId)

	const processLogs = (worklogArray) => {

		// if (worklogArray.length === 1) return []
		const condensed = worklogArray.map(worklog => {
			const { date, workstep } = worklog
			return { date, workstep }
		})

		// make a map of the earliest occurences of all listed steps
		const worklogMap = new d3.rollup(condensed, D => d3.min(D.map(d => d.date)), d => d.workstep.stepName)

		// define hurdles
		const hurdles = [
			"Tourenplanung", "VB II", "Termin", "NB I", "Fertigstellung", "Prüfung", "Freigabe", "Versand", "Rechnung", "Zahlung"
		]

		const hurdleDates = condensed.filter(worklog => hurdles.includes(worklog.workstep.stepName))
		// loop through and increase date if below previous
		let previousDate = null
		const timeline = new d3.InternMap(hurdles.filter(hurdleName => worklogMap.has(hurdleName)) // relevantHurdles in order
			.map(hurdleName => {
				if (worklogMap.get(hurdleName) > previousDate) previousDate = worklogMap.get(hurdleName)
				return [hurdleName, previousDate]
			}))

		// everything else is just contacting the client

		const contactDates = condensed.filter(worklog => hurdles.includes(worklog.workstep.stepName) === false)

		// get VB Is: before Tourenplanung
		const VBIMatches = contactDates.filter(worklog => worklog.date <= worklogMap.get("Tourenplanung"))
		if (VBIMatches.length) {
			timeline.set("VB I", d3.min(VBIMatches, d => d.date))
		}

		// VB I done between set audit date and audit counts as VB II
		const VBIIMatches = contactDates.filter(worklog => worklog.date >= worklogMap.get("Tourenplanung") &&  worklog.date <= worklogMap.get("Termin"))
		if (VBIIMatches.length) {
			const earliestMatch = d3.min(VBIIMatches, d => d.date)
			if (worklogMap.has("VB II")) {
				timeline.set("VB II", d3.min([worklogMap.get("VB II"), earliestMatch]))
			} else {
				timeline.set("VB II", earliestMatch)
			}
		}

		const NBIIMatches = contactDates.filter(worklog => worklog.date >= worklogMap.get("Termin") && worklog.date <= worklogMap.get("Fertigstellung"))
		if (NBIIMatches.length) {
			timeline.set("NB II", d3.min(NBIIMatches, d => d.date))
		}

		// we're not sorting shit, we're frankensteining this together
		const finalArray = 	[
			"VB I", "Tourenplanung", "VB II", "Termin", "NB I", "NB II", "Fertigstellung", "Prüfung", "Freigabe", "Versand", "Rechnung", "Zahlung"
		].map(stepName => [stepName, timeline.get(stepName)]).filter(stepAndDateTuple => !!stepAndDateTuple[1])
		return finalArray
	}

	sortedWorklogsByAuditId.keys().forEach(auditId => {
		const logs = sortedWorklogsByAuditId.get(auditId)
		if (!logs) throw Error(auditId)
		const cleanedLogs = processLogs(logs)
		// now make the whole slew of "+1 -1" etc out of em
		if (logs.length >= 1) {
			let previousStatus = null
			const progression = [["Beginn", minDate], ...cleanedLogs].map(tuple => {
				if (previousStatus === null) {
					previousStatus = tuple[0]
					return { statusName: tuple[0], date: tuple[1], valueChange: 1 }
				}
				const statusChange = [
					{ statusName: previousStatus, date: tuple[1], valueChange: -1 },
					{ statusName: tuple[0], date: tuple[1], valueChange: 1 }
				]
				previousStatus = tuple[0]
				return statusChange
			})
			sortedWorklogsByAuditId.set(auditId, progression.flat())
		}
	})

	// add a running value to each statusId

	// first, group per statusID
	const valueChangePerStatusId = d3.group(Array.from(sortedWorklogsByAuditId.values()).flat(),
		d => d.statusName)

	for (const statusId of valueChangePerStatusId.keys()) {
		const entriesInStatus = valueChangePerStatusId.get(statusId)

		let valueProgression = 0
		const valueChangePerDay = d3.rollups(entriesInStatus, D => d3.sum(D.map(d => d.valueChange)), d => d.date)
			// console.log(Array.from(valueChangePerDay.keys())
			.sort((D1, D2) => D1[0] - D2[0])
			.map(D => {
				const change = D[1]
				valueProgression += change
				return [ D[0], { date: D[0], status: statusId, value: change, valueProgression }]
			})

		valueChangePerStatusId.set(statusId, valueChangePerDay)
	}

	const statusOrder = ["Beginn", "VB I", "Tourenplanung", "VB II", "Termin", "NB I", "NB II", "Fertigstellung", "Prüfung", "Freigabe", "Versand", "Rechnung", "Zahlung"]
	const lastKnownState = new d3.InternMap(statusOrder.map(key => [key, { value: 0, valueProgression: 0 }]))
	const byDate = d3.rollups(Array.from(valueChangePerStatusId.values()).flat().map(D => D[1]).sort((a, b) => a.date - b.date), D => new d3.InternMap(D.map(d => [d.status, d])), d => d.date)

	for (const dateStack of byDate) {
		const [dateKey, InternMap] = dateStack
		// add empty values
		let dayStackSum = 0
		statusOrder.forEach(status => {
			if (InternMap.has(status) === false) {
				InternMap.set(status, { status, date: dateKey, value: 0, valueProgression: lastKnownState.get(status).valueProgression })
			} else {
			lastKnownState.set(status, { ...InternMap.get(status) })
			}

			// stacking!
			const currentVal = InternMap.get(status)
			InternMap.set(status, { ...currentVal, stackStart: dayStackSum, stackEnd: dayStackSum + currentVal.valueProgression })
			dayStackSum += currentVal.valueProgression
		})

		dateStack[1] = Array.from(InternMap.values())

	}

	const margin = { left: 50, top: 10, bottom: 50, right: 10 }
	const canvas = svg
		.append("g")
		.attr("class", "canvas")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)

	const axes = svg.append("g").attr("class", "axes")

	const xScale = d3.scaleTime()
		.domain([new Date(refYear, 0, 1), new Date(refYear + 1, 5, 30)])
		.range([0, width - margin.left - margin.right])

	xScale.clamp(true)

	const yScale = d3.scaleLinear()
		.domain([0, sortedWorklogsByAuditId.size])
		.range([height - margin.bottom, 0])
		.nice()

	axes
		.append("g")
		.attr("class", "x axis")
		.attr("transform", `translate(${margin.left}, ${height + margin.top - margin.bottom})`)
		.call(d3.axisBottom(xScale))

	axes
		.append("g")
		.attr("class", "y axis")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)
		.call(d3.axisLeft(yScale))

	const colorScale = d3.scaleOrdinal([
		...d3.schemeReds[4].reverse(),
		"green",
		...d3.schemeBlues[4],
		"rebeccapurple",
		"black",
		...d3.schemeOranges[4]
	])

	const colorScaleAlt = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, 14])

	const areaGenerator = d3.area(d => xScale(d.date), d => yScale(d.stackStart), d => yScale(d.stackEnd))

	const plots = canvas.selectAll("path").data(d3.group(byDate.map(D => D[1]).flat(), d => d.status))
			.enter()
			.append("path")
			.attr("class", "plot")
			.attr("id", (d) => d)
			.attr("id", (d, i) => i)
			.attr("fill", (d, i) => d3.color(colorScaleAlt(i)).formatHex() + "99")
			.attr("stroke", (d, i) => colorScaleAlt(i))
			.attr("d", d => areaGenerator(d[1]))
	</script>
</body>
</html>
